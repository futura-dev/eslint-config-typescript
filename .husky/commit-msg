#! /bin/sh

# load configuration file
GIT_ROOT=$(git rev-parse --show-toplevel)
source $GIT_ROOT/.cosmokeeper
IS_MONO_REPO=$(cat "${GIT_ROOT}/package.json" | tr -d '\n' | grep -q ",\s*\"workspaces\"" && echo true || echo false);
. "$(dirname $0)/_/husky.sh"

# Array of files modified
FILES=($(git diff --cached --name-only))

# TODO: refactor code with functions
if $IS_MONO_REPO
then

  # MONOREPO

  # Array to store slugs
  SLUGS=()

  # take the paths of packages
  PACKAGE_PATHS=$(find . -type d -name "node_modules" -prune -o -path "./package.json" -prune -o -name "package.json" -type f -print)
  echo $PACKAGE_PATHS

  # Iterate over package json files
  while IFS= read -a PACKAGE_JSON_PATH; do
    # Extract the slug from package.json
    CURR_SLUG=$(egrep -Eo '"slug"\s*:\s*"[^"]+"' $PACKAGE_JSON_PATH | egrep -Eo '"[^"]+"$' | sed 's/"//g')

    # Check if the slug is not empty and not already in the array
    if [[ -n $CURR_SLUG ]] && [[ ! " ${SLUGS[*]} " =~ " $CURR_SLUG " ]]; then
      SLUGS+=("$CURR_SLUG")
    else
      echo "found same slug in multiple packages"
      exit 1
    fi
  done <<< "$PACKAGE_PATHS"

  # Check if the branch name contains any slug
  MATCH_FOUND=false
  BRANCH_NAME=$(git symbolic-ref --short HEAD)
  for SLUG in "${SLUGS[@]}";
  do
    SLUG_PATTERN=$SLUG'@'$BRANCH_PATTERN_BASE
    echo "PATTERN"
    echo $SLUG_PATTERN
    echo "\n"
    if echo $BRANCH_NAME | grep -qE $SLUG_PATTERN;
    then
        MATCH_FOUND=true
        break
    fi
  done

  # exit if branch name does not match any slug
  if ! $MATCH_FOUND;
  then
    echo "ERR"
    exit 1
  fi

  # Array to store unique package names
  UNIQUE_PACKAGES=()

  # Extract the line containing "workspaces" array
  WORKSPACES_LINE=$(egrep -Eo '"workspaces":\s\[.*]' <<< "$(cat "${GIT_ROOT}/package.json" | tr -d '\n')")

  # Remove unnecessary characters from the string
  WORKSPACES_LINE=${WORKSPACES_LINE//\"workspaces\": \[}
  WORKSPACES_LINE=${WORKSPACES_LINE//\]}
  WORKSPACES_LINE=${WORKSPACES_LINE// /}

  IFS=',' read -ra WORKSPACES_RAW <<< "$WORKSPACES_LINE"
  PACKAGES=()

  # Iterate over the workspaces, remove leading and trailing spaces, and append to the array
  for PACKAGE in "${WORKSPACES_RAW[@]}"; do
      PACKAGE=$(echo "$PACKAGE" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -e 's/"//g')
      PACKAGES+=("$PACKAGE")
  done

  # Iterate over modified files
  for FILE in "${FILES[@]}"
  do
    
    # Get the directory path of the modified file
    DIRECTORY=$(dirname "$FILE")
    IDENTIFIED_PACKAGE="root"

    # Identify package of the modified file
    for PACKAGE in "${PACKAGES[@]}"
    do
      if [[ "$DIRECTORY" = *"$PACKAGE"* ]];
      then
        IDENTIFIED_PACKAGE=$PACKAGE;
      fi
    done

    # Check if the package is already in the array
    if ! echo ${UNIQUE_PACKAGES[*]} | grep -qE $IDENTIFIED_PACKAGE;
    then
      UNIQUE_PACKAGES+=("$IDENTIFIED_PACKAGE")
    fi
  done

  # Check if modified files are in different packages
  if [[ ${#UNIQUE_PACKAGES[@]} -gt 1 ]];
  then
    exec < /dev/tty
    echo "Warning: Modified files found in multiple packages."
    read -p "Do you want to allow this commit? (y/n): " ALLOW_COMMIT

    if [[ $ALLOW_COMMIT != "y" ]];
    then
      echo "Commit aborted."
      exit 1
    fi
  fi

else
  # SINGLE

  # check branch naming
  BRANCH_PATTERN=$BRANCH_PATTERN_BASE
  BRANCH_NAME=$(git symbolic-ref --short HEAD)
  if echo $BRANCH_NAME | grep -qE $BRANCH_PATTERN;
  then
    # Branch name is valid
    echo ""
  else
    echo "Error: Branch name '$BRANCH_NAME' does not match the required pattern."
    exit 1
  fi
fi

# COMMON

# looking for files to lint by extensions
# lint matched files

if [ $LINT_ENABLED = true ];
then
  FILES_TO_LINT=()
  for F in "${FILES[@]}"
  do
    if echo $F | egrep -Eq $LINT
    then
    FILES_TO_LINT+=("$F")
    fi
  done

  # Lint files
  npx eslint ${FILES_TO_LINT[*]} --fix
fi

# Check conventional commit
npx --no -- commitlint --edit "$1"
exit 0
